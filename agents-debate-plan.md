# Rewriting all agent prompts completely

**Session ID:** ses_458900114ffeyQocM3tHvGc6Mn
**Created:** 1/10/2026, 3:54:53 PM
**Updated:** 1/10/2026, 4:36:24 PM

---

## User

so based on @prompts.md plz start re writing all prompts of the agents properly completely detailed so the agents gives us better output and everything but based on what were building in this hackathon as per this rough idea @BUREAUCRACY_BREAKER_HACKATHON_ULTIMATE.md and based on this this plan was created @IMPLEMENTATION_PLAN.md  so now start and complete whole propmts of agents properly and proper instructions and everything step by step

---

## Assistant

I'll rewrite all 25 agent prompts with world-class, comprehensive instructions. Let me start by reading the current prompts file and then create detailed prompts for every agent.

```
Tool: read

```

```
Tool: glob

```

```
Tool: glob

```

---

## Assistant

Now let me read the actual prompts template file to understand the current structure:

```
Tool: read

```

```
Tool: read

```

```
Tool: read

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

Now I'll completely rewrite the prompts file with world-class, comprehensive prompts for all 25 agents:

```
Tool: write

```

---

## User

cant you go step by step please dont do everythig at once

---

## Assistant

You're right, I'll go step by step. Let me start with **TIER 1: INTAKE BATTALION** (4 agents) first.

```
Tool: read

```

---

## Assistant

Now I'll rewrite **TIER 1: INTAKE BATTALION** prompts (4 agents). Let me edit the INTENT_DECODER first:

```
Tool: edit

```

---

## Assistant

Now let me update **LOCATION_INTELLIGENCE** agent:

```
Tool: edit

```

---

## Assistant

Now let me update **BUSINESS_CLASSIFIER** agent:

```
Tool: edit

```

---

## Assistant

Now let me update **SCALE_ANALYZER** agent (last one in TIER 1):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

TIER 1 completed. Now let's do **TIER 2: RESEARCH BATTALION** (4 agents). Starting with **REGULATION_LIBRARIAN**:

```
Tool: edit

```

---

## Assistant

Now **POLICY_SCOUT** agent:

```
Tool: edit

```

---

## Assistant

Now **DOCUMENT_DETECTIVE** agent:

```
Tool: edit

```

---

## Assistant

Now **DEPARTMENT_MAPPER** agent (last one in TIER 2):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

TIER 2 completed. Now **TIER 3: STRATEGY BATTALION** (5 agents). Starting with **DEPENDENCY_BUILDER**:

```
Tool: edit

```

---

## Assistant

Now **TIMELINE_ARCHITECT** agent:

```
Tool: edit

```

---

## Assistant

Now **PARALLEL_OPTIMIZER** agent:

```
Tool: edit

```

---

## Assistant

Now **COST_CALCULATOR** agent:

```
Tool: edit

```

---

## Assistant

Now **RISK_ASSESSOR** agent (last one in TIER 3):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

Excellent! TIER 3 completed. Now **TIER 4: DOCUMENT BATTALION** (5 agents). Starting with **FORM_WIZARD**:

```
Tool: edit

```

---

## Assistant

Now **DOCUMENT_VALIDATOR** agent:

```
Tool: edit

```

---

## Assistant

Now **RTI_DRAFTER** agent:

```
Tool: edit

```

---

## Assistant

Now **GRIEVANCE_WRITER** agent:

```
Tool: edit

```

---

## Assistant

Now **APPEAL_CRAFTER** agent (last one in TIER 4):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

TIER 4 completed! Now **TIER 5: EXECUTION BATTALION** (3 agents). Starting with **VISIT_PLANNER**:

```
Tool: edit

```

---

## Assistant

Now **REMINDER_ENGINE** agent:

```
Tool: edit

```

---

## Assistant

Now **STATUS_TRACKER** agent (last one in TIER 5):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

TIER 5 completed! Now **TIER 6: INTELLIGENCE BATTALION** (4 agents). Starting with **CORRUPTION_DETECTOR**:

```
Tool: edit

```

---

## Assistant

Now **COMPARISON_AGENT**:

```
Tool: edit

```

---

## Assistant

Now **WHATIF_SIMULATOR** agent:

```
Tool: edit

```

---

## Assistant

Now **EXPERT_SIMULATOR** (last one in TIER 6):

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

Now the final piece - **GLOBAL/SYSTEM prompts** (orchestrator, compiler, and global identity). Let me update these:

```
Tool: edit

```

---

## Assistant

Now let me update the **FINAL_COMPILER** prompt:

```
Tool: edit

```

---

## Assistant

```
Tool: todowrite

```

---

## Assistant

All 25 agent prompts + global/system prompts have been completely rewritten! Here's a summary of what was done:

---

## COMPLETED: World-Class Agent Prompts Rewrite

### TIER 1: INTAKE BATTALION (4 agents)
- **Intent Decoder**: Comprehensive Hinglish parsing, intent classification with patterns, confidence scoring, step-by-step process
- **Location Intelligence**: City-state mapping, zone detection, state-specific rules, portal URLs
- **Business Classifier**: Complete business taxonomy (50+ subtypes), license mapping, conditional licenses
- **Scale Analyzer**: All Indian thresholds (GST, EPFO, ESIC, FSSAI), MSME classification, inference logic

### TIER 2: RESEARCH BATTALION (4 agents)
- **Regulation Librarian**: Major Indian laws (50+ acts), exemptions, MSME benefits, legal citations
- **Policy Scout**: Recent changes tracking, compliance calendar, regulatory uncertainty handling
- **Document Detective**: Exhaustive checklist with specs (size, format, attestation), 50+ documents covered
- **Department Mapper**: All authorities mapped, portal URLs, escalation paths

### TIER 3: STRATEGY BATTALION (5 agents)
- **Dependency Builder**: Full graph logic, critical path analysis, parallel group identification
- **Timeline Architect**: Realistic timelines (not government claims), adjustment factors, Gantt data
- **Parallel Optimizer**: Week-by-week execution plan, multi-track strategy, time savings calculation
- **Cost Calculator**: Official vs practical costs, DIY vs agent comparison, comprehensive breakdown
- **Risk Assessor**: 5 risk categories, severity/urgency scoring, preventive measures

### TIER 4: DOCUMENT BATTALION (5 agents)
- **Form Wizard**: Field-by-field guidance for GST, FSSAI, Shop Act forms
- **Document Validator**: Comprehensive validation checklist, name/date consistency checks
- **RTI Drafter**: Complete RTI format with legal citations, submission guide
- **Grievance Writer**: CPGRAMS/CM Helpline drafts, escalation strategy
- **Appeal Crafter**: First appeal templates for RTI and license rejections

### TIER 5: EXECUTION BATTALION (3 agents)
- **Visit Planner**: Office-by-office optimization, timing strategy, survival tips
- **Reminder Engine**: Day-by-day reminder schedule, escalation triggers
- **Status Tracker**: Status flow for all licenses, dashboard model, tracking methods

### TIER 6: INTELLIGENCE BATTALION (4 agents)
- **Corruption Detector**: Red flag patterns, citizen rights, legal remedies, escalation paths
- **Comparison Agent**: State-by-state, structure, DIY vs agent comparisons
- **What-If Simulator**: Failure scenario trees with probabilities and recovery plans
- **Expert Simulator**: CA, Lawyer, Business Owner, Mentor perspectives with consensus analysis

### GLOBAL/SYSTEM
- **Global Identity**: Core principles, ethical guidelines, language handling
- **Root Orchestrator**: Agent coordination rules, tier sequencing
- **JSON Rules**: Strict output formatting
- **Final Compiler**: Complete ProcessResult schema, quality checks

---

Each prompt now includes:
- Clear mission statement
- Step-by-step process
- Comprehensive knowledge tables
- Output JSON schema with examples
- Practical tips and edge cases
- Confidence scoring guidance

---

## User

can u explain which are those writer agents or stuff that will need their own pages and how the debate is rela life possible or thats just for show or is it functional and built?

---

## Assistant

Great questions! Let me break this down clearly:

## 1. WRITER AGENTS (Need Their Own Pages/Modals)

These agents generate **actual text drafts** that users need to see, copy, and use:

| Agent | What It Generates | When Triggered | UI Needed |
|-------|-------------------|----------------|-----------|
| **RTI Drafter** | Full RTI application text | When `intent = STUCK_APPLICATION` or user asks | Modal/Page with copy button, placeholders highlighted |
| **Grievance Writer** | CPGRAMS/CM Helpline complaint | When stuck or user complains about corruption | Modal with draft, submission guide |
| **Appeal Crafter** | First appeal for RTI or license rejection | When rejection happens or RTI not answered | Modal with appeal template |

### UI Recommendation for Writer Agents:
```
+------------------------------------------+
|  RTI APPLICATION DRAFT                   |
+------------------------------------------+
|  To: Public Information Officer          |
|  [FIRE_DEPARTMENT] <-- highlighted       |
|                                          |
|  Subject: Application under RTI Act...   |
|                                          |
|  [Full draft text with placeholders]     |
|                                          |
+------------------------------------------+
|  [Copy to Clipboard]  [Download as PDF]  |
|  [Fill Placeholders]  [Submit Guide]     |
+------------------------------------------+
```

---

## 2. AGENT DEBATE - Current Reality

**Honest answer: The debate visualization is NOT fully functional yet - it's partially placeholder.**

Let me check what's actually built:

```
Tool: read

```

---

## Assistant

**Confirmed: It's hardcoded sample data right now.**

### How to Make Agent Debate REAL:

The debate could be functional in two ways:

#### Option A: REAL Debate (Complex but Impressive)
Agents actually pass messages to each other during processing:

```typescript
// In orchestrator, agents emit messages
agentOrchestrator.on('agent-message', (msg) => {
  // msg = { from: "risk-assessor", to: "timeline-architect", 
  //         type: "WARNING", content: "OC missing, Fire NOC will fail" }
  streamToUI(msg);
});
```

This would require:
1. Modifying each agent to emit debate messages
2. Orchestrator to route messages between agents
3. UI to display real-time debate stream

**Effort: 4-6 hours**

#### Option B: SIMULATED Debate (Easier, Still Good)
After all agents complete, generate a debate summary based on their outputs:

```typescript
// After all agents run, analyze conflicts/agreements
const debatePoints = generateDebateFromOutputs({
  riskAssessor: riskOutput,
  timelineArchitect: timelineOutput,
  dependencyBuilder: dependencyOutput
});
```

This would:
1. Compare agent outputs for conflicts
2. Generate debate-style messages
3. Show as if agents discussed

**Effort: 2-3 hours**

---

## 3. What Needs Separate Pages/Components

Based on the vision, here's what should have dedicated UI:

### A. Main Flow Pages
| Page | Purpose |
|------|---------|
| `/dashboard` | Main input + results display |
| `/process/[id]` | Detailed view of a specific analysis |

### B. Modal/Overlay Components
| Component | Trigger | Content |
|-----------|---------|---------|
| `RTIDraftModal` | "Generate RTI" button | Full RTI text, copy, placeholders |
| `GrievanceModal` | "File Grievance" button | Complaint draft |
| `AppealModal` | "Appeal Rejection" button | Appeal template |
| `StateComparisonModal` | "Compare States" button | Side-by-side comparison |
| `ExpertAdviceModal` | "Expert Views" tab | CA/Lawyer/Owner perspectives |

### C. Visualization Components (In Results)
| Component | Shows |
|-----------|-------|
| `AgentDebateViewer` | Agent collaboration (needs wiring) |
| `ProcessDependencyGraph` | What depends on what (needs wiring) |
| `GanttTimeline` | Week-by-week timeline (needs building) |
| `CostBreakdownChart` | Pie/bar chart of costs |

---

## 4. My Recommendation for Demo

**For the hackathon demo, I'd prioritize:**

1. **Make Agent Debate work (Option B - Simulated)** - 2 hours
   - Parse agent outputs
   - Generate debate-style messages showing conflicts/consensus
   - Display in AgentDebateViewer

2. **Add RTI Draft display** - 1 hour
   - When intent is STUCK_APPLICATION
   - Show RTI draft in modal
   - Copy button

3. **Wire dependency graph** - 1 hour
   - Use actual nodes/edges from result
   - Simple visualization

Would you like me to:
1. **Wire the AgentDebateViewer to real data** (simulated approach)?
2. **Create the RTI/Grievance modal components**?
3. **Fix the dependency graph visualization**?

Which should I tackle first?

---

## User

if we want optino a for debate how can we do that can u show me reall plan?

---

## Assistant

Great choice! Option A (Real Debate) is way more impressive for the hackathon. Let me show you the complete plan.

---

# REAL AGENT DEBATE - Implementation Plan

## How It Works (Concept)

```
┌─────────────────────────────────────────────────────────────────┐
│                      ORCHESTRATOR                                │
│                                                                  │
│  Agent 1 runs ──► Emits findings ──► Stored in shared context   │
│       │                                                          │
│       ▼                                                          │
│  Agent 2 runs ──► Sees Agent 1's findings                       │
│       │          ──► Agrees/Disagrees                           │
│       │          ──► Emits debate message                       │
│       ▼                                                          │
│  Agent 3 runs ──► Sees Agent 1 & 2's findings                   │
│       │          ──► References their points                    │
│       │          ──► Adds own perspective                       │
│       ▼                                                          │
│  ... continues ...                                               │
│                                                                  │
│  All debate messages streamed to UI in real-time                │
└─────────────────────────────────────────────────────────────────┘
```

## The Architecture

```
Tool: read

```

---

## Assistant

```
Tool: read

```

---

## Assistant

```
Tool: read

```

---

## Assistant

Now I understand the architecture. Let me create a complete implementation plan for **Real Agent Debate**:

---

# REAL AGENT DEBATE - Complete Implementation Plan

## Overview

The idea is to make agents **aware of each other's outputs** and **emit debate messages** when they agree, disagree, or build on other agents' findings.

## Architecture

```
┌──────────────────────────────────────────────────────────────────────┐
│                         CURRENT FLOW                                  │
│                                                                       │
│   Agent 1 ──► output ──► Agent 2 ──► output ──► Agent 3 ──► ...     │
│   (Each agent only produces its structured output)                   │
└──────────────────────────────────────────────────────────────────────┘

                              ▼ BECOMES ▼

┌──────────────────────────────────────────────────────────────────────┐
│                          NEW FLOW                                     │
│                                                                       │
│   Agent 1 ──► output + debateMessages ──►                            │
│   Agent 2 ──► reads Agent 1's output                                 │
│          ──► produces output + debateMessages (references Agent 1)   │
│   Agent 3 ──► reads Agent 1 & 2's outputs                            │
│          ──► produces output + debateMessages (agrees/disagrees)     │
│                                                                       │
│   All debateMessages streamed to UI with type: "debate"              │
└──────────────────────────────────────────────────────────────────────┘
```

## Implementation Steps

### Step 1: Create Debate Message Type

```
Tool: read

```

---

## Assistant

```
Tool: read

```

---

## Assistant

Now I have a clear picture. Here's the **complete implementation plan**:

---

# COMPLETE IMPLEMENTATION PLAN: Real Agent Debate

## Phase 1: Add Debate Types (5 mins)

**File: `types/agents.ts`**

```typescript
// Add new debate message type
export interface DebateMessage {
  id: string;
  timestamp: number;
  from: string;           // Agent ID who's speaking
  fromDisplayName: string; // "Risk Assessor"
  type: "observation" | "agreement" | "disagreement" | "question" | "consensus" | "warning" | "insight";
  referencesAgent?: string;  // Which agent they're responding to
  content: string;           // The actual message
  confidence?: number;
  data?: unknown;            // Any supporting data
}

export interface DebateThread {
  topic: string;             // "Fire NOC Timeline"
  messages: DebateMessage[];
  consensusReached: boolean;
  finalPosition?: string;
}
```

## Phase 2: Modify Agent Prompts to Emit Debate (30 mins)

The key insight: **Each agent's prompt already knows about other agents**. We just need to tell them to:
1. Review previous agents' findings (available in session state)
2. Emit debate messages when they have something to say about those findings

**Add to each agent's prompt (example for Risk Assessor):**

```
=== DEBATE PARTICIPATION ===
You are part of a multi-agent debate. Before producing your output, review what other agents have said (available in context).

If you have observations about other agents' findings, include a "debateMessages" array in your output:

"debateMessages": [
  {
    "type": "disagreement",
    "referencesAgent": "timeline_architect", 
    "content": "I disagree with the 35-day timeline. Without OC verification, Fire NOC will add 30+ days.",
    "confidence": 0.9
  },
  {
    "type": "warning",
    "referencesAgent": "document_detective",
    "content": "The document list is missing OC verification - this is CRITICAL for Fire NOC.",
    "confidence": 0.95
  }
]

DEBATE GUIDELINES:
- Only emit debate messages when you have genuine insights about other agents' work
- Be specific - reference exact findings you agree/disagree with
- Disagreements should include your reasoning
- Agreements can highlight why the finding is important
- Warnings should flag risks other agents may have missed
```

## Phase 3: Modify Orchestrator to Extract & Stream Debate (45 mins)

**File: `lib/agents/orchestrator.ts`**

Add debate extraction and streaming:

```typescript
// Add new stream item type
export type OrchestratorStreamItem =
  | { type: "event"; /* existing */ }
  | { type: "debate"; message: DebateMessage }  // NEW
  | { type: "complete"; /* existing */ };

// In runQuery, extract debate messages from agent outputs
for await (const event of runner.runAsync({ userId, sessionId, newMessage })) {
  // ... existing event handling ...
  
  // NEW: Extract debate messages from agent output
  if (isFinalResponse(event) && event.author) {
    const agentOutput = parseAgentOutput(event);
    if (agentOutput?.debateMessages) {
      for (const msg of agentOutput.debateMessages) {
        yield {
          type: "debate",
          message: {
            id: crypto.randomUUID(),
            timestamp: Date.now(),
            from: event.author,
            fromDisplayName: getAgentDisplayName(event.author),
            ...msg
          }
        };
      }
    }
  }
}
```

## Phase 4: Update API to Stream Debate Events (15 mins)

**File: `app/api/analyze/route.ts`**

```typescript
for await (const item of orchestrator.runQuery(query, { userId, sessionId })) {
  if (item.type === "event") {
    // existing
  } else if (item.type === "debate") {
    // NEW: Stream debate messages
    controller.enqueue(
      sseEncode("debate", item.message)
    );
  } else if (item.type === "complete") {
    // existing
  }
}
```

## Phase 5: Create Debate UI Component (1 hour)

**File: `components/agents/AgentDebateViewer.tsx`**

```typescript
"use client";

import { useState, useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { motion, AnimatePresence } from "framer-motion";
import type { DebateMessage } from "@/types";

interface AgentDebateViewerProps {
  messages: DebateMessage[];
  isLive?: boolean;
}

const typeColors = {
  observation: "bg-blue-500/20 text-blue-400 border-blue-500/30",
  agreement: "bg-green-500/20 text-green-400 border-green-500/30",
  disagreement: "bg-red-500/20 text-red-400 border-red-500/30",
  question: "bg-yellow-500/20 text-yellow-400 border-yellow-500/30",
  consensus: "bg-purple-500/20 text-purple-400 border-purple-500/30",
  warning: "bg-orange-500/20 text-orange-400 border-orange-500/30",
  insight: "bg-cyan-500/20 text-cyan-400 border-cyan-500/30",
};

const typeLabels = {
  observation: "Observes",
  agreement: "Agrees",
  disagreement: "Disagrees",
  question: "Questions",
  consensus: "Consensus",
  warning: "Warns",
  insight: "Insight",
};

export function AgentDebateViewer({ messages, isLive = false }: AgentDebateViewerProps) {
  return (
    <Card className="h-full">
      <CardHeader className="pb-3">
        <div className="flex items-center justify-between">
          <CardTitle className="text-lg">Agent Debate</CardTitle>
          {isLive && (
            <Badge variant="outline" className="animate-pulse">
              <span className="mr-1.5 h-2 w-2 rounded-full bg-green-500" />
              Live
            </Badge>
          )}
        </div>
      </CardHeader>
      <CardContent className="space-y-3 max-h-[500px] overflow-y-auto">
        <AnimatePresence>
          {messages.map((msg, idx) => (
            <motion.div
              key={msg.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: idx * 0.1 }}
              className="rounded-lg border bg-card/50 p-3"
            >
              <div className="flex items-start justify-between gap-2 mb-2">
                <div className="flex items-center gap-2">
                  <span className="font-semibold text-sm">{msg.fromDisplayName}</span>
                  {msg.referencesAgent && (
                    <span className="text-xs text-muted-foreground">
                      → {msg.referencesAgent}
                    </span>
                  )}
                </div>
                <Badge 
                  variant="outline" 
                  className={`text-xs ${typeColors[msg.type]}`}
                >
                  {typeLabels[msg.type]}
                </Badge>
              </div>
              <p className="text-sm text-muted-foreground">{msg.content}</p>
              {msg.confidence && (
                <div className="mt-2 text-xs text-muted-foreground">
                  Confidence: {(msg.confidence * 100).toFixed(0)}%
                </div>
              )}
            </motion.div>
          ))}
        </AnimatePresence>
        
        {messages.length === 0 && (
          <div className="text-center text-muted-foreground py-8">
            {isLive ? "Waiting for agents to start debating..." : "No debate messages yet"}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

## Phase 6: Connect to Dashboard (30 mins)

**In Dashboard component, collect debate messages from stream:**

```typescript
const [debateMessages, setDebateMessages] = useState<DebateMessage[]>([]);

// In SSE handler
eventSource.addEventListener("debate", (e) => {
  const message = JSON.parse(e.data);
  setDebateMessages(prev => [...prev, message]);
});

// In JSX
<AgentDebateViewer messages={debateMessages} isLive={isProcessing} />
```

---

## Which Agents Should Debate?

Not all agents need to debate. Focus on these **key debaters**:

| Agent | Debate Role | What They Debate About |
|-------|-------------|------------------------|
| **Risk Assessor** | Primary Debater | Challenges timelines, flags missing risks |
| **Timeline Architect** | Primary Debater | Defends/adjusts timelines based on risks |
| **Dependency Builder** | Supporting | Points out sequencing issues |
| **Cost Calculator** | Supporting | Highlights cost implications of risks |
| **Expert Simulator** | Synthesizer | Provides consensus view from experts |
| **Corruption Detector** | Warning Role | Flags process red flags |

---

## Example Debate Flow

**User Query:** "Restaurant in Mumbai"

```
[Risk Assessor]: 
  type: "warning"
  content: "I notice Location Intelligence identified this as Mumbai. 
            BMC area has 40% higher Fire NOC rejection rate. 
            Recommending early OC verification."

[Timeline Architect]: 
  type: "agreement"
  referencesAgent: "risk_assessor"
  content: "Agree with Risk Assessor. Adjusting Fire NOC estimate 
            from 21 days to 35 days for Mumbai BMC area."

[Dependency Builder]: 
  type: "insight"
  content: "Given the Fire NOC risk, I've restructured the critical path. 
            OC verification is now the FIRST dependency, not parallel."

[Cost Calculator]: 
  type: "observation"  
  referencesAgent: "timeline_architect"
  content: "Extended timeline means additional Rs 15,000-20,000 in 
            rent before revenue. Adding to practical costs."

[Expert Simulator]: 
  type: "consensus"
  content: "All agents agree: OC verification before lease signing is critical. 
            Experienced restaurant owner perspective confirms this is the 
            #1 mistake new restaurateurs make in Mumbai."
```

---

## Timeline to Implement

| Phase | Task | Time |
|-------|------|------|
| 1 | Add types | 5 mins |
| 2 | Update 5-6 agent prompts | 30 mins |
| 3 | Modify orchestrator | 45 mins |
| 4 | Update API route | 15 mins |
| 5 | Create UI component | 1 hour |
| 6 | Connect to dashboard | 30 mins |
| **Total** | | **~3 hours** |

---

## Want Me to Start Implementing?

I can start with:
1. **Phase 1 & 2**: Add types and update the key agent prompts to emit debate messages
2. **Phase 3 & 4**: Modify orchestrator and API
3. **Phase 5 & 6**: Build the UI

Which phase should I start with?

---

